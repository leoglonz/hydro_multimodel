"""
This is a testing environment for building dPL hydrologic model BMI.
"""
import logging
import os

from networkx import bidirectional_dijkstra
import numpy as np
import pandas as pd
import torch
import tqdm
from conf.config import Config
from core.calc.normalize import trans_norm
from core.calc.stat import stat_error
from core.data import take_sample_test
from core.data.dataFrame_loading import load_data
from core.utils import save_outputs
from core.utils.Dates import Dates
from models.model_handler import ModelHandler
from models.multimodels.ensemble_network import EnsembleWeights

from models.bmi.dpl_bmi import BMIdPLHydroModel


# Read configuration file.
try:
    from ruamel.yaml import YAML
except ModuleNotFoundError:
    print("YAML Module not found.")

config_path = "bmi_config.yaml"
yaml = YAML(typ="safe")
path = os.path.realpath(config_path)
config = open(path, "r")
config = yaml.load(config)


# Create instance of BMI model.
model = BMIdPLHydroModel()

# Initialize the BMI.
model.initialize(bmi_cfg_filepath=config_path)

# TODO: Get forcing and attribute data
# ... (take from bmi_train.py)...
forcings = {}
attributes = {}

n_forcings = forcings['prcp(mm/day)'].size

# TODO: write a timestep handler/translator so we can control we can pull out
# forcings/attributes for the specific timesteps we want streamflow predictions for.

# Loop through and return streamflow at each timestep.
for t in range(n_forcings):
    # NOTE: for each timestep in this loop, the data assignments below are of
    # arrays of basins. e.g., forcings['key'].shape = (1, # basins)

    # TODO: Finish map of camels attribute/forcing data to CSDMS names.
    # Set forcings...
    model.setvalue('atmosphere_water__liquid_equivalent_precipitation_rate', forcings['prcp(mm/day)'])
    model.setvalue('land_surface_air__temperature', forcings['tmean(C)'])
    model.setvalue('_________', forcings['PET_hargreaves(mm/day)'])

    # Set attributes...
    model.setvalue('atmosphere_water__daily_mean_of_liquid_equivalent_precipitation_rate', attributes['p_mean'])
    model.setvalue('land_surface_water__daily_mean_of_potential_evaporation_flux', attributes['pet_mean'])
    model.setvalue('_________', attributes['p_seasonality'])
    model.setvalue('atmosphere_water__precipitation_falling_as_snow_fraction', attributes['frac_snow'])
    model.setvalue('ratio__mean_potential_evapotranspiration__mean_precipitation', attributes['aridity'])
    model.setvalue('atmosphere_water__frequency_of_high_precipitation_events', attributes['high_prec_freq'])
    model.setvalue('atmosphere_water__mean_duration_of_high_precipitation_events', attributes['high_prec_dur'])
    model.setvalue('atmosphere_water__precipitation_frequency', attributes['low_prec_freq'])
    model.setvalue('atmosphere_water__low_precipitation_duration', attributes['low_prec_dur'])
    model.setvalue('basin__mean_of_elevation', attributes['elev_mean'])
    model.setvalue('basin__mean_of_slope', attributes['slope_mean'])
    model.setvalue('basin__area', attributes['area_gages2'])
    model.setvalue('land_vegetation__forest_area_fraction', attributes['frac_forest'])
    model.setvalue('land_vegetation__max_monthly_mean_of_leaf-area_index', attributes['lai_max'])
    model.setvalue('land_vegetation__diff_max_min_monthly_mean_of_leaf-area_index', attributes['lai_diff'])
    model.setvalue('land_vegetation__max_monthly_mean_of_green_vegetation_fraction', attributes['gvf_max'])
    model.setvalue('land_vegetation__diff__max_min_monthly_mean_of_green_vegetation_fraction', attributes['gvf_diff'])
    model.setvalue('_________', attributes['dom_land_cover_frac'])
    model.setvalue('_________', attributes['dom_land_cover'])
    model.setvalue('_________', attributes['root_depth_50'])
    model.setvalue('soil_bedrock_top__depth__pelletier', attributes['soil_depth_pelletier'])
    model.setvalue('soil_bedrock_top__depth__statsgo', attributes['soil_depth_statsgo'])
    model.setvalue('soil__porosity', attributes['soil_porosity'])
    model.setvalue('soil__saturated_hydraulic_conductivity', attributes['soil_conductivity'])
    model.setvalue('maximum_water_content', attributes['max_water_content'])
    model.setvalue('soil_sand__volume_fraction', attributes['sand_frac'])
    model.setvalue('soil_silt__volume_fraction', attributes['silt_frac'])
    model.setvalue('soil_clay__volume_fraction', attributes['clay_frac'])
    model.setvalue('_________', attributes['geol_1st_class'])
    model.setvalue('_________', attributes['glim_1st_class_frac'])
    model.setvalue('_________', attributes['geol_2nd_class'])
    model.setvalue('_________', attributes['glim_2nd_class_frac'])
    model.setvalue('basin__carbonate_rocks_area_fraction', attributes['carbonate_rocks_frac'])
    model.setvalue('_________', attributes['geol_porosity'])
    model.setvalue('bedrock__permeability', attributes['geol_permeability'])

    # Update the model at all basins for one timestep.
    model.update()
    print(f"Streamflow at time {model.t} is {model.streamflow_cms}")

# Finalize the BMI once updating is complete.
model.finalize()

















